# Global defaults shared by all releases.
global:
  # Ingress host/protocol used to build URLs.
  domain: localhost
  # Optional list of ingress hosts; when set, overrides global.domain.
  # Use a list of host strings (e.g., ["qwe.asd", "foo.bar"]).
  hosts: []
  protocol: http
  image:
    # Optional registry/prefix for all images (e.g. "registry.local/myrepo").
    registry: ""
  # Optional global storage class for PVCs.
  storageClassName: ""
  # Shared ServiceAccount name for gfs-user + logs collector.
  gfsUser:
    username: gfs-user
  # Shared ingress subpaths (kebab-case keys).
  paths:
    grafana: /grafana
    # Use camelCase keys to match vendored Victoria charts.
    victoriaMetrics: /victoria-metrics
    victoriaLogs: /victoria-logs
    victoriaTraces: /victoria-traces
    vmagent: /vmagent
  # Shared service ports (camelCase keys).
  ports:
    grafana: 3000
    # Use camelCase keys to match vendored Victoria charts.
    victoriaMetrics: 8428
    victoriaLogs: 9428
    victoriaTraces: 9410
    # OTLP gRPC port for victoria-traces (ingestion).
    victoriaTracesOtlpGrpc: 4317
    vmagent: 8429
  # Optional imagePullSecrets applied to all charts that support it.
  imagePullSecrets: []
  scrapers:
    # Optional global scrape targets for vmagent.
    # Leave empty when using per-release vmagent.scrapeTargets.
    metricsTargets: []
  # Cluster name added as log attribute for multi-cluster filtering (e.g. clusterName:prod).
  clusterName: ""

# Service and scraper overrides are centralized here.
grafana:
  # Custom Grafana image with offline plugins.
  image:
    repository: limitium/grafanaplg
    tag: 11.2.0-with-vl.5
    pullPolicy: IfNotPresent
  ingress:
    enabled: true
    className: nginx
  server:
    # Serve from global.paths.grafana.
    serveFromSubPath: true
  datasources:
    enabled: true
  plugins:
    - victoriametrics-logs-datasource
  persistence:
    # Override only the PVC size; other settings use chart defaults.
    size: 1Gi
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi

victoria-metrics:
  # VictoriaMetrics image/version.
  image:
    repository: victoriametrics/victoria-metrics
    tag: "v1.110.0"
    pullPolicy: IfNotPresent
  ingress:
    enabled: true
    className: nginx
    annotations:
      nginx.ingress.kubernetes.io/use-regex: "true"
  persistence:
    # Storage for time series data.
    enabled: true
    size: 1Gi
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi

victoria-logs:
  # VictoriaLogs image/version.
  image:
    repository: victoriametrics/victoria-logs
    tag: "latest"
    pullPolicy: IfNotPresent
  ingress:
    enabled: true
    className: nginx
    annotations:
      nginx.ingress.kubernetes.io/use-regex: "true"
  persistence:
    # Storage for logs data.
    enabled: true
    size: 1Gi
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi

victoria-traces:
  # VictoriaTraces image/version.
  image:
    repository: victoriametrics/victoria-traces
    tag: "latest"
    pullPolicy: IfNotPresent
  ingress:
    enabled: true
    className: nginx
    annotations:
      nginx.ingress.kubernetes.io/use-regex: "true"
  persistence:
    # Storage for traces data.
    enabled: true
    size: 1Gi
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi

vmagent:
  enabled: true
  # Metrics scraper image/version.
  image:
    repository: victoriametrics/vmagent
    tag: "v1.110.0"
    pullPolicy: IfNotPresent
  ingress:
    enabled: true
  # Additional scrape targets (appended to default self-monitoring jobs).
  # Default jobs (victoria-metrics, victoria-logs, victoria-traces, grafana) are always included.
  scrapeTargets:
    - job_name: demo-apps
      metrics_path: /metrics
      static_configs:
        - targets:
            # These are the default service names created by the demo-apps chart.
            - demo-apps-grafascope-demo-apps-service-a:8000
            - demo-apps-grafascope-demo-apps-service-b:8000
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi

victoria-logs-collector:
  enabled: true
  # DaemonSet log collector image/version.
  image:
    registry: ""
    repository: victoriametrics/vlagent
    tag: "v1.43.1"
    variant: ""
    pullPolicy: IfNotPresent
  serviceAccount:
    # Use gfs-user ServiceAccount by default.
    create: false
    automount: true
    annotations: {}
    name: gfs-user # defaults to global.gfsUser.username when set
  remoteWrite:
    # Explicit URL to VictoriaLogs insert endpoint.
    # Include the namespace prefix when http.pathPrefix is enabled:
    #   http://victoria-logs:9428/<namespace>/victoria-logs/insert/native
    # For the default namespace used here:
    #   http://victoria-logs:9428/grafascope/victoria-logs/insert/native
    - url: "http://victoria-logs:9428/grafascope/victoria-logs/insert/native"
      headers: {}
  collector:
    # Basic field mapping for log parsing.
    timeField: ["time", "ts", "timestamp"]
    msgField: ["message", "msg"]
    excludeFilter: ""
    includePodLabels: true
    includePodAnnotations: false
    includeNodeLabels: false
    includeNodeAnnotations: false
  env: []
  # Centralized resources (override chart defaults).
  resources:
    requests:
      cpu: "1"
      memory: 1Gi
    limits:
      memory: 1Gi
  podAnnotations: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}

fluent-bit:
  # Optional log tailer that does not use Kubernetes API.
  luaScripts:
    parse_container_path.lua: |
      function parse_container_path(tag, timestamp, record)
        local path = record["_path"]
        if not path then return 1, timestamp, record end
        local filename = path:match("([^/]+)$") or ""
        filename = filename:gsub("%.log$", "")
        filename = filename:gsub("%-[0-9a-fA-F]{64}$", "")
        local parts = {}
        for part in (filename .. "_"):gmatch("(.-)_") do
          table.insert(parts, part)
        end
        if #parts >= 3 then
          record["kubernetes_pod_name"] = table.concat(parts, "_", 1, #parts - 2)
          record["kubernetes_namespace"] = parts[#parts - 1]
          record["kubernetes_container_name"] = parts[#parts]
        end
        local pod_name = record["kubernetes_pod_name"]
        if pod_name then
          local segs = {}
          for s in (pod_name .. "-"):gmatch("(.-)-") do
            table.insert(segs, s)
          end
          if #segs >= 3 then
            record["service"] = table.concat(segs, "-", 1, #segs - 2)
          elseif #segs == 2 then
            record["service"] = segs[1]
          elseif #segs == 1 then
            record["service"] = segs[1]
          end
        end
        record["_path"] = nil
        return 2, timestamp, record
      end
  kind: DaemonSet
  resources:
    requests:
      cpu: 250m
      memory: 30M
    limits:
      memory: 1G
  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    # runAsNonRoot: true
  serviceAccount:
    create: false
    name: "" # defaults to global.gfsUser.username when set
  rbac:
    create: false
    nodeAccess: false
    eventsAccess: false
  config:
    service: |
      [SERVICE]
          Daemon Off
          Flush 1
          Log_Level info
          Parsers_File /fluent-bit/etc/parsers.conf
          Parsers_File /fluent-bit/etc/conf/custom_parsers.conf
          HTTP_Server On
          HTTP_Listen 0.0.0.0
          HTTP_Port 2020
          Health_Check On
    inputs: |
      [INPUT]
          Name tail
          Path /var/log/containers/*.log
          Path_Key _path
          multiline.parser docker, cri
          Tag kube.*
          Mem_Buf_Limit 5MB
          Skip_Long_Lines On
    filters: |
      # Extract pod, namespace, container from /var/log/containers filename (pod_namespace_container-id.log).
      [FILTER]
          Name lua
          Match kube.*
          script /fluent-bit/scripts/parse_container_path.lua
          call parse_container_path
      # Parse log field as JSON so _msg, service, trace_id etc. are queryable in VictoriaLogs.
      [FILTER]
          Name parser
          Match kube.*
          Key_Name log
          Parser json
      # Ensure _msg exists for plain-text logs (e.g., ingress/nginx).
      [FILTER]
          Name modify
          Match kube.*
          Condition Key_does_not_exist _msg
          Copy log _msg
      {{- if and .Values.global .Values.global.clusterName }}
      # Add cluster label for multi-cluster querying.
      [FILTER]
          Name modify
          Match kube.*
          Add cluster {{ .Values.global.clusterName | quote }}
      {{- end }}
      # No Kubernetes filter (avoids API calls).
    outputs: |
      [OUTPUT]
          Name http
          Match kube.*
          Host victoria-logs
          Port 9428
          # Include the namespace prefix when http.pathPrefix is enabled:
          # /<namespace>/victoria-logs/insert/jsonline
          URI /grafascope/victoria-logs/insert/jsonline?_stream_fields=stream,kubernetes_pod_name,kubernetes_namespace,kubernetes_container_name,service{{- if and .Values.global .Values.global.clusterName }},cluster{{- end }}&_msg_field=_msg,log&_time_field=date
          Format json_lines
          Header Content-Type application/json
          Json_date_format iso8601
  daemonSetVolumes:
    - name: varlog
      hostPath:
        path: /var/log/pods
        type: Directory
    - name: varlibdockercontainers
      hostPath:
        path: /var/log/containers
    - name: etcmachineid
      emptyDir: {}
  daemonSetVolumeMounts:
    - name: varlog
      mountPath: /var/log/pods
      readOnly: true
    - name: varlibdockercontainers
      mountPath: /var/log/containers
      readOnly: true
    - name: etcmachineid
      mountPath: /tmp/etc/machine-id
      readOnly: true

gfs-user:
  # ServiceAccount + RBAC for log collectors and scrapers.
  nameOverride: ""
  fullnameOverride: ""
  serviceAccount:
    # Set false if SA/RBAC is created outside Helm.
    create: true
    name: gfs-user # should match global.gfsUser.username
  rbac:
    # Set false if Role/Binding is created outside Helm.
    create: true
    # true => ClusterRole/ClusterRoleBinding (required if you include cluster-scoped resources like nodes/namespaces/PVs)
    # false => Role/RoleBinding (namespace-scoped; you must remove cluster-scoped resources from the list)
    clusterWide: true
    roleName: "gfs-user-role"
    bindingName: "gfs-user-binding"
    apiGroups:
      - ""
      - apps
      - autoscaling
      - batch
      - extensions
      - policy
      - rbac.authorization.k8s.io
    resources:
      - pods
      - componentstatuses
      - configmaps
      - daemonsets
      - deployments
      - deployments/scale
      - events
      - endpoints
      - horizontalpodautoscalers
      - ingress
      - jobs
      - cronjobs
      - limitranges
      - namespaces
      - nodes
      - persistentvolumes
      - persistentvolumeclaims
      - resourcequotas
      - replicasets
      - replicationcontrollers
      - serviceaccounts
      - services
    verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
